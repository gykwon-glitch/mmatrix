---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
devtools::load_all()
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# mmatrix

<!-- badges: start -->

<!-- badges: end -->

mmatrix provides a safe, sparse, and reproducible formula-to-matrix pipeline for high-dimensional data. It extends R’s base `model.matrix()` workflow by offering transparent collinearity handling, stable factor encoding, and detailed reporting of dropped or aliased columns. The package centers on a main constructor that builds a sparse design matrix and a frozen encoding specification (“spec”) containing factor levels, contrasts, and transformation rules for consistent application to new data.

## Installation

You can install the development version of mmatrix from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("gykwon-glitch/mmatrix")
```

## Basic usage
This section shows a typical workflow:

1. Build a sparse design matrix and encoding spec from training data.
2. Inspect sparsity / rank / dropped columns.
3. Apply the same schema to new data, including unseen factor levels.

### 1. Build a sparse design matrix and spec
```{r example-build}
library(mmatrix)

set.seed(1)

# Toy training data: turn some variables into factors

train <- within(mtcars, {
cyl      <- factor(cyl) # categorical
am       <- factor(am, labels = c("auto", "manual"))
high_hp  <- factor(ifelse(hp > 120, "high", "low"))
})

# Construct sparse design matrix + encoding spec

fit <- mmatrix(
~ cyl + am + high_hp + wt + hp,
data        = train,
collin_tol  = 1e-9,
na_as_level = FALSE,
other_level = "Other"
)

# Pretty printing: uses print.mmatrix_spec()

print(fit)

# Basic summary: uses summary.mmatrix_spec()

summary(fit)

# Under the hood, the sparse design matrix is in `fit$X`

dim(fit$X)
Matrix::nnzero(fit$X)

```

### 2. Inspect the design and factor encodings
You can get a compact report of the design matrix, collinearity drops, and
factor levels via `mm_report()`:
```{r example-report}
mm_report(fit)
```
This prints:

* n x p, number of nonzeros, and density/sparsity,
* approximate memory usage for sparse vs dense representation,
* estimated rank (from QR),
* a head of drop_report (columns dropped because of all-zero or aliased),
* a preview of factor levels used in the encoding.

If you only want the returned object (without printing), you can capture it:
```{r example-report2}
rep_obj <- mm_report(fit)
str(rep_obj, max.level = 1)
```

### 2.1 Example: dropped columns from collinearity and all-zero

```{r example-drop}
# Create a version of the training data with redundant columns
train_drop <- within(train, {
  hp_dup   <- hp   # perfectly collinear with hp
  all_zero <- 0    # all-zero column
})

fit_drop <- mmatrix(
  ~ cyl + am + high_hp + wt + hp + hp_dup + all_zero,
  data        = train_drop,
  collin_tol  = 1e-9,
  na_as_level = FALSE,
  other_level = "Other"
)

mm_report(fit_drop)

```

### 3. Apply the schema to new data
To apply the same encoding (same columns & ordering) to new data, use `mm_predict()`.
```{r example-predict}
# New data with the same variables

newdata <- data.frame(
cyl      = factor(c(4, 6), levels = levels(train$cyl)),
am       = factor(c("manual", "auto"), levels = levels(train$am)),
high_hp  = factor(c("high", "low"), levels = levels(train$high_hp)),
wt       = c(2.2, 3.0),
hp       = c(150, 90)
)

# Apply the training schema to new data

X_new <- mm_predict(fit$spec, newdata = newdata, unknown = "other")
X_new

```

Here:

* `fit$spec` is the encoding specification created by `mmatrix()`
(formula, terms object, levels map, column order, etc.).
* The returned `X_new` is a `Matrix::sparseMatrix` with the same columns
and ordering as `fit$X`.

### 4. Handling unseen factor levels
`mm_predict()` lets you control what happens when newdata contains
levels that never appeared in the training data.
```{r example-unknown}
# Introduce an unseen level for 'cyl' and 'high_hp'

newdata2 <- data.frame(
cyl      = factor(c(4, 10), levels = c("4", "6", "8", "10")),
am       = factor(c("manual", "auto"), levels = levels(train$am)),
high_hp  = factor(c("high", "medium"), levels = c("high", "low", "medium")),
wt       = c(2.2, 3.0),
hp       = c(150, 90)
)

# 1) Map unseen levels to the "Other" bucket in the encoding

X_other <- mm_predict(fit$spec, newdata2, unknown = "other")

# 2) Map unseen levels to the baseline (first training level)

# Under default treatment contrasts, this yields all-zero dummies.

X_zero <- mm_predict(fit$spec, newdata2, unknown = "zero")

dim(X_other)
dim(X_zero)

```

* `unknown = "other"`: unseen levels are mapped to the other_level
specified in `mmatrix()` (e.g. `"Other"`), and encoded accordingly.
* `unknown = "zero"`: unseen levels are mapped to the baseline level
(first training level), which typically yields all-zero dummy columns
under default treatment contrasts.
* `unknown = "error"`: any unseen level causes an error, which can be useful
in production pipelines where strict schema matching is required.

